
--10년 1월 1일 기준 근속년수가 10 초과인 직원의 이름
SELECT EMP_NAME, TRUNC(MONTHS_BETWEEN('10/01/01' , HIRE_DATE)/12) AS 근속
FROM EMPLOYEE
WHERE TRUNC(MONTHS_BETWEEN('10/01/01' , HIRE_DATE)/12) > 10;

--사번이 100인 직원의 이름과 급여 출력해보자
SELECT EMP_NAME, SALARY 
FROM EMPLOYEE
WHERE EMP_ID = TO_CHAR(100); //명시 형변환

-- 이름과 입사일을 별칭으로 출력하되 입사일은 0000-00-00 형식으로 출력하기, 단 J7 직군만 출력한다.
SELECT EMP_NAME AS 이름, TO_CHAR(HIRE_DATE, 'YYYY-MM-DD') AS 입사일
FROM EMPLOYEE
WHERE JOB_ID = 'J7';

-- JOB ID가 J1, J2인 사원의 이름, 기본 입사일, 상세 입사일을 별칭으로 출력한다, 단 상세 입사일을 0000/00/00 00:00:00D으로 출력한다.
SELECT EMP_NAME AS 이름, HIRE_DATE AS 기본입사일, TO_CHAR(HIRE_DATE, 'YYYY/MM/DD HH24:MI:SS') AS 상세입사일
FROM EMPLOYEE
WHERE JOB_ID IN('J1','J2');

-- 90/04/01 입사자를 출력하는 두가지 방법
SELECT EMP_NAME, HIRE_DATE
FROM EMPLOYEE
WHERE TO_CHAR(HIRE_DATE, 'YYMMDD') = '900401';

SELECT EMP_NAME, HIRE_DATE
FROM EMPLOYEE
WHERE HIRE_DATE = TO_DATE('900401 133030','YYMMDD HH24MISS');

-- ORACLE의 세기

SELECT '2009/10/14' AS 현재,   '95/10/27' AS 입력,
TO_CHAR(TO_DATE('95/10/27','YY/MM/DD'),'YYYY/MM/DD') AS YY형식1, //YY 형식으로 입력됐기때문에 현재 세기로 기입된다. 2095
TO_CHAR(TO_DATE('95/10/27','YY/MM/DD'),'RRRR/MM/DD') AS YY형식2,
TO_CHAR(TO_DATE('95/10/27','RR/MM/DD'),'YYYY/MM/DD') AS RR형식1,//RR 형식으로 입력됐기 때문에 현재를 50년 아래로 판단하여 아래 세기로 기입한다 1995
TO_CHAR(TO_DATE('95/10/27','RR/MM/DD'),'RRRR/MM/DD') AS RR형식2
FROM DUAL;

-- 기타 단일 행 함수 = DECODE
-- SELECT 구문으로 IF-ELSE 논리를 제한적으로 구현한 오라클 함수
DECODE(expr,search1,result1[, searchN, resultN,...][, default])
expr : 대상 컬럼 혹은 문자열
search1 : expr과 비교하려는 값
result1 : IF expr = search1 인 경우 반환
default : expr과 search1 이 일치하지 않은 경우의 기본 리턴값, default 지정하지 않고 expr 과 search1이 일치하지 않으면 NULL값 리턴

SELECT EMP_NAME, DECODE(SUBSTR(EMP_NO,8,1),'1','남','3','남','여') AS 성별
FROM EMPLOYEE;

SELECT EMP_ID AS 번호, EMP_NAME AS 이름, DECODE(MGR_ID,NULL,'없음',MGR_ID) AS 관리자
FROM EMPLOYEE;
-- 유사 (NULL 처리는 NVL 기억)
SELECT EMP_ID AS 번호, EMP_NAME AS 이름, NVL(MGR_ID,'없음') AS 관리자
FROM EMPLOYEE;

-- 직군에 따른 급여 인상
SELECT EMP_NAME AS 이름, JOB_ID AS 직군 , TO_CHAR(SALARY, 'L999,999,999') AS 봉급,
TO_CHAR(DECODE(JOB_ID,'J7', SALARY*1.1,'J6', SALARY*1.15,'J5', SALARY*1.2, SALARY*1.05),'L999,999,999')
AS 인상급여
FROM EMPLOYEE;

--DECODE와 유사한 ANSI 표준 구문
CASE expr WHEN search1 THEN result1
SELECT EMP_NAME AS 이름,
JOB_ID AS 직군 , 
TO_CHAR(SALARY, 'L999,999,999') AS 봉급,
CASE JOB_ID
WHEN 'J7' THEN SALARY*1.1
WHEN 'J6' THEN SALARY*1.15
WHEN 'J5' THEN SALARY*1.2
ELSE SALARY*1.05 END AS 인상급여
FROM EMPLOYEE;

SELECT EMP_ID AS 번호, EMP_NAME AS 이름,
CASE
WHEN SALARY<=3000000 THEN '초급'
WHEN SALARY<=4000000 THEN '중급'
ELSE '고급' END AS "봉급 구분"
FROM EMPLOYEE;


--이메일 아이디만 출력
SELECT EMP_NAME AS 이름,
EMAIL AS 이메일,
SUBSTR(EMAIL,0,INSTR(EMAIL,'@')-1) AS ID 
FROM EMPLOYEE;

-- 평균 NULL 제외 중복 제외
SELECT AVG(BONUS_PCT) AS 기본평균,
AVG(DISTINCT BONUS_PCT) AS 중복제거평균,
AVG(NVL(BONUS_PCT,0)) AS NULL포함평균
FROM EMPLOYEE;


-- JOIN(ORACLE)

SELECT EMP_NAME, DEPT_NAME 
FROM EMPLOYEE E, DEPARTMENT D
WHERE E.DEPT_ID = D.DEPT_ID;
  
--JOIN 방법 (ANSI)
SELECT *
FROM TABLE1{
      [INNER]JOIN TABLE2 ON (condition [AND condition 2...]) |
      [INNER]JOIN TABLE2 USING (column [,..]) |
      NATURAL [INNER] JOIN TABLE2 |
      LEFT | RIGHT | FULL [OUTER] JOIN TABLE2 ON (condition [AND condition 2...]) |
      LEFT | RIGHT | FULL [OUTER] JOIN TABLE2 USING (condition [AND condition 2...]) |
      CROSS JOIN TABLE2}
WHERE ...


-- INNER JOIN (INNER 생략 가능)
SELECT EMP_NAME,DEPT_ID,DEPT_NAME
FROM EMPLOYEE
INNER JOIN DEPARTMENT
USING (DEPT_ID);

  
SELECT EMP_NAME,DEPT_ID,DEPT_NAME
FROM EMPLOYEE
INNER JOIN DEPARTMENT
ON (DEPT_ID = DEPTNO); -- DEPT_ID와 DEPTNO가 관리하는 값은 같지만 다른 열명을 가졌을때

COL 지역 FORMAT A20
SELECT DEPT_NAME AS 부서번호, LOC_DESCRIBE AS 지역
FROM DEPARTMENT
JOIN LOCATION
ON (LOC_ID = LOCATION_ID);

-- ORACLE
SELECT DEPT_NAME, LOC_DESCRIBE
FROM DEPARTMENT, LOCATION
WHERE LOC_ID = LOCATION_ID;

-- OUTER JOIN 과 INNER JOIN의 차이는, OUTER JOIN은 NULL, FALSE값이어도 반환, INNER JOIN은 TRUE값만 반환한다는 것이다.
SELECT *
FROM X
JOIN Z  -- NULL, FALSE 안나옴
ON(X2=Z1);

-- LEFT JOIN하면 LEFT의 테이블이 주, JOIN뒤 테이블이 종이되어 주 테이블의 모든 정보가 출력된다(JOIN에 해당되지 않더라도)

SELECT *
FROM X LEFT JOIN Z
ON(X2 = Z1);

        X1         X2         Z1         Z2
---------- ---------- ---------- ----------
         1        111        111          2
         3        444        444          4

         4        555
         2        333
         
-- ORACLE (+키워드 주면 종)
SELECT *
FROM X, Z
WHERE X.X2 = Z.Z1(+);

-- FULL OUTER JOIN (모든 행이 다 출력)
SELECT *
FROM X FULL JOIN Z
ON(X2=Z1);

-- CROSS JOIN  (모든 조합 결과 리턴)
SELECT *
FROM X CROSS JOIN Z;

-- JOIN (Non Equijoin) 범위에 속하는지 확인하는 JOIN
사원의 이름과 봉급, 등급 출력
SELECT ENAME, SAL, GRADE
FROM EMP
JOIN SALGRADE
ON(SAL BETWEEN LOSAL AND HISAL);

-- ORACLE
SELECT ENAME, SAL, GRADE
FROM EMP, SALGRADE
WHERE SAL BETWEEN LOSAL AND HISAL;

--SELF JOIN (하나의 테이블을 두개의 별칭을 선언하여 조인)
SELECT E.ENAME AS 직원,
M.ENAME AS 관리자
FROM EMP E
LEFT JOIN EMP M -- 두개의 별칭 (누구도 매니저로 갖지 않는 인원을 위해 OUTER JOIN)
ON (E.MGR = M.EMPNO); -- EMPLOYEE의 MGR가 MANAGER의 EMPLOYEE NUMBER
